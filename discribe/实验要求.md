# 实验三：一个简单的分布式键值存储系统

进入你从我们实验 Git 仓库克隆下来的文件夹，并拉取最新的提交：

```
git pull
```

你可以在 `Lab3/README.md` 中找到本实验的说明。

所有实验三的材料都在 `Lab3/` 文件夹中。

## 1. 概述

你将实现一个简单的分布式内存键值数据库（KV 存储），通过两阶段提交协议（2PC）或 Raft 协议来保证你实现的 KV 存储系统的一致性和鲁棒性。

### 实验目标

- 理解构建分布式系统中遇到的问题和挑战；
- 学习如何使用简单的协议在多个分布式服务器之间维持一致性；
- 学会使用一些基本策略来应对服务器故障。

## 2. 背景知识

### 2.1 键值存储（KV store）

内存键值数据库（又称键值存储，本文档中简称 KV 存储）是一种将所有数据存储在主内存中，并使用简单键值对结构的数据库。

通常，KV 存储提供以下接口以供用户存储、删除和读取数据：

- `set(key, value)`：将值 `value` 存储为键 `key` 的值（有些 KV 存储也称其为 `put` 命令）；
- `del(key)`：删除与键 `key` 相关的所有记录；
- `value=get(key)`：检索并返回键 `key` 对应的值。

在实际应用中，内存 KV 存储一般通过主内存响应大部分用户请求，同时会将数据备份到硬盘以增强持久性。但在本实验中，你无需考虑数据持久性，即只需要将数据存储于主内存中即可。

### 2.2 分布式 KV 存储

在大规模云服务中，为了性能和鲁棒性，KV 存储通常以分布式方式构建。

例如，一个 KV 存储可以将数据分布在多个服务器上，同时使用这些服务器来处理用户请求。（**数据分片**是将数据按某种策略分布到不同的服务器或节点上。每个服务器负责存储一部分数据，这样可以分散负载，提高系统的扩展性。）（**请求路由**：当用户请求的数据不在当前服务器上时，系统需要能够将请求路由到存储数据的正确服务器上。**中央路由表**：所有的服务器共享一个中心路由表，知道每个数据存储在哪个服务器上。**分布式路由表**：每个节点根据自己负责的数据和路由规则，能够知道如何将请求路由到其他节点。）如此一来，在请求量高峰时可以实现负载均衡，并在部分服务器失效时仍能继续服务。

然而，一旦 KV 数据库是分布式的，就会出现很多问题，**其中一致性问题尤为著名且棘手**。比如：假设数据库部署在服务器 A 和 B 上。用户 1 向 A 存储了某个键值对，紧接着用户 2 和用户 3 分别向 A 和 B 查询这个键，此时如何保证他们都能获取到**最新一致的值**？更具挑战性的是，在用户请求的同时，服务器或网络可能会出现故障。

接下来我们会介绍一种非常经典且简单的协议，用于保障分布式数据库服务器之间的**一致性。**

### 2.3 两阶段提交（2PC）

我们现在来介绍一种最简单（但确实有效！）的一致性协议：**两阶段提交（2PC）**。该协议可以保障当数据库分布在多个服务器时的数据一致性，即多个服务器**要么同时完成某项操作，要么全部不做**，是原子性的。这里只做简要介绍，想深入了解的话可以自行查阅资料（例如 [this](https://www.bilibili.com/video/BV1at411y7iQ)  很不错）。

- 首先，2PC 在每台服务器上维护一个**提交日志（commit log）**，用于记录是否提交。日志保障了所有机器**要么全部提交，要么全部不提交**；
- 其次，有一个**全局协调者（coordinator）**。它从客户端接收事务（如 set、delete、get 操作），将结果返回客户端，同时协调多个数据库服务器确保事务一致地提交或中止。

2PC 协议包含两个阶段：

#### 第一阶段：**准备阶段（prepared phase）**

协调者向所有数据库服务器（即参与者）发送请求，要求它们承诺提交或回滚事务。参与者将承诺记录在日志中，然后返回 ACK。如果有任何一个参与者投反对票（abort），协调者将记录“Abort”并通知所有人中止操作，每台机器也相应地记录“Abort”。

#### 第二阶段：**提交或中止阶段（commit-or-abort phase）**

当所有参与者都表示“准备好了”之后，协调者记录“Commit”，并让所有参与者执行提交操作；所有参与者执行后返回 ACK。协调者收到所有 ACK 后记录“Got Commit”。

![two-phase-commit](E:\CloudComputingLabs\Lab3\src\two-phase-commit.png)

2PC 的详细步骤如下：

#### 准备阶段：

1. 协调者发送 `REQUEST-TO-PREPARE` 给所有参与者；
2. 等待所有参与者投票；
3. 参与者收到消息后投票：
   - 若准备提交，发送 `PREPARED`；
   - 若本地失败不能提交，发送 `NO`；
   - 若因网络原因无法回应，则可能无限期等待。

#### 提交或中止阶段：

1. 若协调者收到所有 `PREPARED` 消息，则决定提交事务；否则中止；
2. 协调者将决定（COMMIT 或 ABORT）发送给所有参与者；
3. 参与者收到后回复 `DONE`；
4. 协调者收到所有 `DONE` 后可以将结果返回客户端并释放资源。

### 2.4 Raft 协议

2PC 协议无法处理“协调者本身失效”的场景，因此你也可以使用如 Raft 等扩展方法。

更多内容参见 第 4.2 节。

## 3. 你的实验任务

### 3.1 任务概览

<img src="C:\Users\ruixi\AppData\Roaming\Typora\typora-user-images\image-20250511162016367.png" alt="image-20250511162016367" style="zoom:80%;" />

你需要实现一个简单的分布式键值存储系统（KV store）。你的 KV store 应作为网络服务运行在远程机器上，通过网络消息接收客户端对数据库的操作，并返回结果。为了应对故障，你需要将你的服务部署在**多台互联的机器上**，并使用 **2PC 协议**来在多台机器间保持数据库一致性。

为简化任务，你的 KV 存储数据只需存储在内存中，2PC 协议的日志也只需保存在内存中即可。

下面是具体的实验要求。

------

### 3.2 KV 存储命令格式

你的 KV 存储服务器只需要支持三种数据库命令：`SET`、`GET` 和 `DEL`（大小写敏感）。这些命令（包括参数）和返回结果都要用一种**特定的网络消息格式**进行封装。为简便起见，KV 存储中所有的键和值都以字符串形式存储。

#### 3.2.1 网络消息格式

本实验使用一种**简化版 RESP 协议（Redis 序列化协议）**来编码客户端发送给服务器的请求（request）和服务器返回给客户端的响应（response）。

##### 3.2.1.1 客户端请求消息

客户端使用 RESP 数组格式发送命令。格式如下：

- 以 `*` 开头，后跟数组元素数量（十进制），再跟回车换行（CRLF）；
- 接着是若干个字符串（bulk string），每个字符串格式为：
  - 以 `$` 开头，后跟字符串长度（十进制），再跟 CRLF；
  - 字符串内容；
  - 再跟一个 CRLF。

例子：字符串 `CS06142` 被编码为：

`$7\r\nCS06142\r\n`

一个字符串数组被编码为：

`*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n`

##### 3.2.1.2 服务器响应消息

1. **成功消息**：

格式为：以 `+` 开头，后跟字符串（不含换行符），以 CRLF 结尾。例如：

`+OK\r\n`

1. **错误消息**：

格式为：以 `-` 开头，后跟错误字符串，以 CRLF 结尾。例如：

`-ERROR\r\n` 

1. **RESP 数组消息**：

执行 `GET` 命令成功时，服务器返回 RESP 数组格式。例如：

```
*2\r\n$5\r\nCloud\r\n$9\r\nComputing\r\n
```

1. **整数消息**：

某些命令（如 `DEL`）需返回整数值。格式为以 `:` 开头的整数，结尾为 CRLF。例如：

```
:1\r\n
```

------

#### 3.2.2 数据库命令

##### 3.2.2.1 `SET` 命令

格式：`SET key value`，作用是将指定 key 设置为某个字符串值，若 key 已存在则覆盖。

示例命令：

```
SET CS06142 "Cloud Computing"
```

该命令对应的 RESP 编码为：

```
*4\r\n$3\r\nSET\r\n$7\r\nCS06142\r\n$5\r\nCloud\r\n$9\r\nComputing\r\n
```

**成功时返回：**

```
+OK\r\n
```

**失败时返回：**

```
-ERROR\r\n
```

------

##### 3.2.2.2 `GET` 命令

格式：`GET key`，作用是获取指定 key 的值，若 key 不存在返回 `nil`。

示例命令：

```
GET CS06142
```

对应的 RESP 编码为：

```
*2\r\n$3\r\nGET\r\n$7\r\nCS06142\r\n
```

**成功返回示例（假设值为 "Cloud Computing"）：**

```
*2\r\n$5\r\nCloud\r\n$9\r\nComputing\r\n
```

**key 不存在时返回(nil)：**

```
*1\r\n$3\r\nnil\r\n
```

**发生错误时返回：**

```
-ERROR\r\n
```

------

##### 3.2.2.3 `DEL` 命令

格式：`DEL key1 key2 ...`，删除一个或多个 key，**返回实际删除的 key 数量**（不存在的 key 会被忽略）。

示例命令：

```
DEL CS06142 CS162
```

对应 RESP 编码为：

```
*3\r\n$3\r\nDEL\r\n$7\r\nCS06142\r\n$5\r\nCS162\r\n
```

**返回示例：**

```
:1\r\n
```

（注：只删除了 `CS06142`，`CS162` 不存在）

**错误返回：**

```
-ERROR\r\n
```

### 3.3 使用 2PC 协议在多台服务器上构建一个 KV 存储系统（基础版本）

你需要实现协调者（**coordinator**）和参与者（**participant**）两个程序。

- **协调者**不存储任何数据。它的职责是接收并解析来自客户端的 KV 命令，运行 2PC 协议来协调参与者一致地执行这些命令，并将执行结果返回给客户端。*整个系统中只有一个协调者*。
- 每个**参与者**在其内存中维护一个 KV 数据库，接收协调者发送的 KV 命令，执行后将结果返回给协调者。

协调者与参与者之间的通信格式不限。你可以继续使用前面介绍的 RESP 协议，也可以使用其他 RPC 库。

------

### 3.4 使用 Raft 协议在多台服务器上构建一个 KV 存储系统（高级版本）

在实现高级版本之前，请仔细阅读 2.4 节对 Raft 算法的介绍。

有几个重点：

- 测试脚本会**随机选择一个服务节点发送请求**，因为系统的领导者（leader）是随机选出的，测试脚本事先并不知道谁是 leader。
- 因此，如果一个服务节点不是 leader，它需要**拒绝该请求，并返回正确的 leader 信息**，脚本再会向 leader 重新发送请求。
- leader 与 follower 之间的通信格式不限，可使用 RESP 或其他 RPC 机制。

------

### 3.5 运行你的程序

#### 3.5.1 程序参数

你的程序需要支持命令行长参数，就像实验二一样。程序运行时只能接收一个参数：`--config_path`，它指定了配置文件的路径。所有的配置信息都写在这个配置文件中。你的程序需要读取并解析这个文件，并根据其中的内容决定作为协调者还是参与者运行。

------

**基础版本**的程序命名为 `kvstore2pcsystem`：

- 启动**协调者**进程，例如配置文件是 `./src/coordinator.conf`：

```
./kvstore2pcsystem --config_path ./src/coordinator.conf
```

- 启动**参与者**进程，例如配置文件是 `./src/participant.conf`：

```
./kvstore2pcsystem --config_path ./src/participant.conf
```

只要你正确执行上述命令，程序应能自动运行，无需其他输入。

------

**高级版本（Raft 实现）**的程序命名为 `kvstoreraftsystem`：

例如启动某个服务节点：

```
./kvstoreraftsystem --config_path ./src/follower.conf
```

程序应在启动后自动运行，无需额外输入。

------

#### 3.5.2 配置文件格式

**基础版本配置文件**包含两类行：

1. **注释行**：以 `!` 开头的整行，程序不会解析；
2. **参数行**：以参数名开头，后跟一个空格，再跟参数值。

基础版本中配置文件的三个合法参数为：

- `mode`：运行模式，为 `coordinator` 或 `participant`，并且**必须是第一个参数行**；
- `coordinator_info`：协调者监听的 IP:端口 地址，客户端和参与者通过它与协调者通信；
- `participant_info`：参与者监听的 IP:端口 地址。

> 协调者的配置文件中会有多行 `participant_info`；
>  参与者的配置文件中只写自己的 `participant_info` 和协调者的 `coordinator_info`。

------

**基础版协调者配置文件示例**：

```
! Coordinator configuration
mode coordinator
coordinator_info 127.0.0.1:8001
participant_info 127.0.0.1:8002 
participant_info 127.0.0.1:8003 
participant_info 127.0.0.1:8004
```

**基础版参与者配置文件示例**：

```
! Participant configuration
mode participant
participant_info 127.0.0.1:8002
coordinator_info 127.0.0.1:8001
```

------

**高级版本（Raft）配置文件**与基础版类似，但**不再需要 `mode` 行**。

每个节点都需要配置自己的监听地址以及整个集群中所有节点的地址，以便互相通信。

**高级版配置文件示例**：

```
! configuration of advanced version
follower_info 127.0.0.1:8001
follower_info 127.0.0.1:8002
follower_info 127.0.0.1:8003
```

## 4. 实现要求

### 4.1 基础版本（满分 18 分）

为了完成 Lab4，你**至少需要完成 Lab3 的基础版本第2级别**。

如果你想在 Lab4 中获得优秀成绩，建议你尝试完成 第 4.2 节：高级版本（20 分）。

------

#### 4.1.1 第一级：基础版本（15 分）

你的程序应该完成第 3.1 至第 3.4 节中描述的所有任务。系统必须能够**正确接收和执行 KV 命令，并返回相应结果**。

在这个版本中：

- **不会有参与者故障**；
- **不会注入任何网络故障**；
- 但网络可能偶尔丢包，你可以使用 TCP 协议来处理这些丢包情况。

此外，**协调者进程可能在任何时刻被强制终止并重启多次**。因此，**不要在协调者中存储任何数据库数据**。

- 协调者运行时会处理客户端的 KV 命令；
- 协调者挂掉时，你的系统不需要响应客户端请求；
- 客户端会持续重发命令直到获得成功响应；
- 协调者不记录历史（除配置文件），每次重启都将所有命令当作新命令来处理。

你的程序应能在至少 3 个参与者上正确运行。

------

#### 4.1.2 第二级：基础版本（16 分）

在完成第一级别所有内容基础上，这一版本中：

- **参与者可能故障**；
- **网络链路可能失效**；
- 故障为**一次性（one-shot）**，即一旦失败就永不恢复；
- 协调者仍可能随时被终止并重启多次；
- 协调者运行时仍需处理客户端请求；
- 协调者挂掉时无需响应客户端；
- 协调者**不记录任何历史信息**，所以每次重启后需要**重新检测参与者存活状态**。

你的协调者应能：

- 通过**周期性心跳**检测参与者是否失效（比如：多次无响应就判断失效）；
- 一旦某个参与者死亡，应**将其从系统中移除**；
- 剩下的参与者应仍能正确处理客户端的 KV 命令；
- 如果所有参与者都失败，协调者应返回 `ERROR` 给客户端。

你的程序应能在至少 3 个参与者上正确运行。

> 🌸 **注意：报名演示 demo3 的同学，至少需要完成高级版本！**

------

#### 4.1.3 第三级：基础版本（18 分）

在前两级的基础上，这一版本要求：

- **参与者和网络链路的故障既可能是永久性的，也可能是临时性的（会恢复）**；
- 协调者仍可随时被杀死并重启多次；
- 协调者需支持：
  - 检测参与者的失效与恢复；
  - 失效后移除该参与者；
  - 恢复后重新将该参与者加入系统；
- 恢复后的参与者需**同步最新 KV 数据库**，以保证一致性；
- 我们不会提供同步协议，你需要自行设计正确的同步机制。

💡 **举个例子**：

> 有两个参与者 A 和 B，A 先宕机，之后恢复，随后 B 宕机。
>  在这段时间里，客户端可能持续发送命令；
>  A 恢复后需要同步期间的更新，否则 B 挂掉后系统就不一致啦！

我们会**随机注入故障与恢复**，为方便测试：

- 每当参与者（或其网络）恢复后，**保证后续 10 秒内不会再有任何故障**；
- 你的协调者应在这 10 秒内完成数据库同步；
- 同时，我们保证**始终至少有一个活着的参与者**，这样协调者就总能处理请求。

你的程序应能在至少 3 个参与者上正确运行。

> 🍁 **注意：报名演示 demo4 的同学，至少需要完成基础第三级版本！**

------

### 4.2 高级版本（20 分）

由于协调者可能**永久性失败**，你需要构建一个**能在没有协调者的情况下继续处理客户端请求**的系统。

2PC 协议无法解决这个问题。因此你需要使用**更高级的共识协议**（例如 Raft）。

#### 你的系统应该是这样的：

- 每台服务器都可以接收客户端请求、存储数据并返回响应；
- 客户端预先配置好所有服务器地址；
- 客户端可**随机向任意服务器发送命令**；
- 为保证一致性：
  - 通常只有一个**leader** 处理请求；
  - leader 会将数据备份到其他服务器；
  - 非 leader 的服务器会重定向请求给 leader；
- 共识协议应能：
  - 检测 leader 的故障并重新选举；
  - 在多台服务器之间维持数据库一致性。

建议使用 [Raft](https://raft.github.io/) 协议。你可以阅读它的论文，也可以参考一些开源实现。或者设计你自己的协议也可以，只要它**正确**就行。

> 🧙‍♀️ 提示：如果你想在 Lab4 拿高分，**Raft 通常比 2PC 更靠谱！**

## 5. 实验提交

请将你所有的代码放在 `Lab3` 文件夹中，并编写一个 `Makefile`，以便我们**只用一个命令 `make` 就能编译你的代码**。

> 编译出的可执行文件应命名为：
>
> - 基础版本：`kvstore2pcsystem`
> - 高级版本：`kvstoreraftsystem`

并且应放在 `Lab3` 文件夹下。

请严格按照以上规则操作，以便助教能自动化测试你的代码！！！

你可以使用任何可用的代码或库来完成此实验。欢迎你在网上搜索资料。但是，**严禁抄袭其他小组的代码**！

> 📌 本实验**不需要提交性能测试报告**，请轻松愉快地享受实验过程吧 😊

请按照 总实验指南 中的说明提交你的程序（路径为 `../README.md`）。

------

## 6. 实验三测试器

你可以在这个仓库中找到测试器：[lab3_tester](https://github.com/LabCloudComputing/CloudComputing_Lab3_tester)

实验三的测试脚本会在之后更新，以支持高级版本的测试。

------

## 7. 评分标准

- 如果你完成了**基础版本的所有要求**，你可以获得：

  ✅ **18 分**

- 如果你完成了**高级版本的所有要求**，你可以获得：

  🏆 **20 分（满分）**